
# CPU (Central Process Unit)
명령어를 읽고, 해석하고, 연산하고, 실행하는 장치 

## 구성요소

**Register**
- 데이터를 임시적으로 저장하는 공간
- PC (Program Counter), 명령어 레지스터, 메모리 주소 레지스터, 메모리 버퍼 레지스터, 플래그 레지스터 처럼 특수한 상황에서 쓰는 레지스터가 있고 일반적인 상황에서 쓸 수 있는 범용 레지스터가 존재

**Controller**
- 명령어를 해석하고 제어 신호를 생성하는 장치
- 클럭 (Clock, 컴퓨터 부품이 움직일 수 있는 시간 단위) 마다 명령어와 플래그 레지스터의 값, 외부에서 온 제어신호까지 고려해서 제어신호를 생성
- 생성된 제어 신호는 CPU 내부 뿐만 아니라 제어 버스를 통해 CPU 외부로도 이동

**ALU**
- Arithmetic Logic Unit의 줄임말로 산술연산과 논리연산을 진행
- 다음과 같이 두 피연산자와 제어신호 (+ 계산인지, & 연산인지 등등)를 통해 계산하고 플래그값(오버플로우가 됐는지 caryy가 발생했는지 등등)과 결과값을 레지스터에 저장
<img src = "https://github.com/user-attachments/assets/b8a68a62-bb0e-4f7a-842d-156d65a0061c" width = "500">

## 명령어 사이클
- CPU는 하나의 명령어를 정형화된 흐름을 통해 처리함
- 인출 사이클 (fetch cycle)
  - 메모리에서 명령어를 가져와서 레지스터에 저장하는 단계
- 실행사이클 (execution cycle)
  - 가져온 명령어를 읽고 해석하여 실행하는 단계
- 간접사이클 (indirect cycle)
  - 명령어의 오퍼랜드 (operand)가 데이터를 가지고 있는 주소를 가리키는 주소값을 가지고 있을 때 메모리 접근을 두번 해야함
- 인터럽트
  - 인출 사이클이 다시 실행되기 전에 인터럽트가 발생했는 지 확인하고 인터럽트가 있으면 인터럽트 서비스 루틴을 실행한 후 다시 돌아와서 작업을 재개한다


## CPU 성능 향상법
모든 컴퓨터 부품은 클럭 단위로 움직인다.
클럭 속도가 빨라지면 명령어 처리 속도가 높아져 CPU 성능이 좋아진다.
하지만, 너무 빨라지면 발열 문제가 발생해 한계가 있다.

### 멀티 코어와 멀티 스레드
제어장치, 레지스터, ALU 하나의 단위를 '코어'로 묶어서 멀티 코어 CPU를 사용
한 번에 처리할 수 있는 명령어는 많아지지만 코어마다 연산을 적절히 잘 분배해야 성능 향상을 기대할 수 있다.
ex. 조별인원이 늘어난다고 한 번에 처리할 수 있는 양이 많아지진 않음

멀티 스레드는 하나의 코어가 동시에 처리하는 명령어 단위로 소프트웨어 단위의 스레드와는 달리 '하드웨어 스레드'라고도 부른다.

### 파이프라이닝
하나의 명령어가 실행되는 단계를 더 세분화하면
1. 명령어 인출
2. 명령어 해석
3. 명령어 실행
4. 결과 저장
   으로 나눌 수 있다.
각 단계가 사용하는 장치는 겹치지 않기 때문에 단계별로 다른 명령어가 실행될 수 있으며 이를 파이프라이닝이라고 한다.

그러나 파이프라이닝을 할 때 위험이 존재하는데

**데이터 위험** -> 어떤 명령어가 완전히 실행되어야 비로소 실행될 수 있는 경우 (ex. a+b의 값을 대입하는 명령어)

**제어 위험** -> 분기 처럼 다른 명령어의 위치로 변경하는 경우 미리 파이프라이닝이 된 다음 명령어들은 필요 없어짐 -> 분기 예측으로 해결

**구조적 위험** -> 서로 다른 명령어가 동일한 CPU 부품을 사용하려는 경우 

### CISC, RISC
CPU마다 이해할 수 있는 명령어 집합 (IS, Instruction Set)가 다르다.

**CISC** (Complex Instruction Set Computer)
- 하나의 명령어가 복잡한 작업을 수행할 수 있음
- 명령어의 전체 개수가 적다보니 컴파일 된 프로그램의 크기가 작다는 장점이 있음
- but, 가변적인 명령어 길이로 주소 지정 방식도 다양하고 명령어 당 실행시간도 일정하지 않음 -> 파이프라이닝을 구현하기 힘듦
- 또한, 생각보다 복잡한 일을 할 수 있는 명령어들의 사용 횟수가 적음

**RISC** (Reduced Intstruction Set Computer)
- 명령어 파이프라이닝을 구축하기 쉽게 명령어 길이를 규격화하고 수행 시간을 짧게 진행
- 간단한 일을 하는 자주 쓰이는 명령어들로 구성
- 명령어 하나로 복잡한 일을 할 수 있었던 CISC와 다르게 작은 명령어 여러 개로 처리해야 하기에 컴파일 된 프로그램의 크기가 CISC보다는 큼


### 캐시 메모리
- CPU 내에서 연산하는 속도보다 메모리에 접근하는 시간이 훨씬 느림 -> 메모리 접근 시간을 줄이면 성능을 높일 수 있음
- CPU에서부터 L1, L2, L3 순서로 계층적으로 존재하고 L3로 갈수록 용량은 커지지만 속도는 느려진다.
  
**캐시 용어**
- 캐시 미스 (cache miss)
  - 찾고자 하는 데이터가 캐시에 없음
  - cold miss -> 처음 요구하는 데이터여서 캐시에 없음
  - conflict miss -> 동일 캐시 공간에 다른 두 데이터를 캐시하고자 함
  - capacity miss -> 캐시 공간이 부족함
- 캐시 히트 (cache hit)
  - 찾고자 하는 데이터가 캐시에 있음
- 캐시 적중률
  - 캐시 히트 / (캐시 히트 + 캐시 미스)


**참조 지역성 원리 (locality of reference)**
  - 캐시는 CPU가 또 사용할 것 같은 데이터를 미리 가지고 있어서 메모리 접근 시간을 줄여줌
  - CPU가 또 사용할 것 같은 데이터는 어떻게 알지?
  - 시간 지역성 (temporal locality)
    - 최근에 사용했던 데이터에 다시 접근할 가능성이 높음. ex. 변수 선언하고 다시 그 변수에 접근함
  - 공간 지역성 (spatial locality)
    - 접근한 데이터의 근처에 접근할 가능성이 높음 ex. 배열 같은 경우 a[0]을 접근했으면 a[1]을 접근할 가능성이 높음
   
  
**캐시 종류**

direct mapped cache
- 캐시의 특정 영역에 대응해서 저장하는 캐시 ex. 주소값의 하위 3비트를 캐시될 영역으로 사용
- conflict miss 발생 가능성 있음
  
fully associative cache
- 캐시 공간에 어디에든 빈 공간에 저장하는 캐시
- 매번 모든 캐시를 탐색해서 원하는 데이터가 있는지 확인해야 함

set associative cache
- 캐시를 특정 블록 집합으로 나누고 블록 안에서는 fully associative 한 캐시
- ex. 32칸의 캐시를 4칸씩 8블록으로 나누고 4칸 내에서는 자유롭게 빈공간에 저장 
