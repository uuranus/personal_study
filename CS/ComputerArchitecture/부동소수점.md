
# 부동소수점
- 컴퓨터에서 **실수를 저장하는 방법** 중 하나
- 고정 소수점과 부동소수점이 있다.

## 고정 소수점 (fixed point)
- **소수점의 위치가 고정**되어 있음
![고정 소수점](https://github.com/uuranus/personal_study/assets/72340294/79fb1204-c2d1-47fd-8a21-f85456abfcbd)


- 11010.001101 을 저장한다고 하면
- 부호 0 정수부 11010 소수부 001101 이라서 0 11010 001101 이라고 저장

- 장점: **읽기가 쉽다.** 그냥 정수부와 소수부 사이에 .만 붙이면 됨
- 단점: **표현 범위가 좁다** 1.10110110110101.... 이런 숫자여도 정수부의 비트를 나눠줄 수 없음

## 부동소수점 (floating point)
- **가수부와 지수부**로 나누어서 소수점의 위치를 표현
- 11011.111010 이런 숫자가 있으면 1.1011111010 * 2^4 로 정규화를 진행
- 그리고 가수부에는 맨 앞 1을 제외한 1011111010을 저장 (**맨 앞이 무조건 1인 것을 알기에 생략**. 나중에 계산할 때는 1을 더해줌)
- **지수부는** 4를 저장하는데 이 때 **bias 값을 더해서 저장**. 32비트는 127, 64비틑 1024이다. **(2^(지수부 비트수 -1) -1)**
- 이는 **부호비트를 사용하지 않게 하기 위함**
- 정수부는 8비트이기에 -2^7 -1 ~ 2^7까지 표현가능. 즉, 2^ (-126~ 127)까지 가능
- 여기에 +127을 해서 저장한다면 1~254로 저장이 되어서 부호비트를 사용하지 않아도 됨

  
- 장점: **표현 범위가 넓어졌다.**
- 단점: **오차 존재**

- 그럼 0이랑 255는 어디에 쓰는가?


### denormalize
- 소수를 1.xxx * 2^yyyy 형태로 바꾼다고 했다.
- 그럼 0.xxx는 없는가?
- 소수점은 최대 왼쪽으로 126칸까지 이동할 수 있는데 만약 **매우매우 작은 숫자**라서 000..00000(126개)011101..이런 숫자가 있다면?
- 0.01101 * 2^ -126 이렇게까지가 최선일 것이다. **0.xxx의 지수는 최대치로 소수점을 땡길 수 있는 2^-126으로 정해지는 것**
- 이 때 exp는 0으로 정해져있기에 지수는 **1-bias 로 계산식이 정해져있다.**
- 이렇게 해서 매우 작은 숫자도 표현 가능

- **지수가 255로 다 1111인 경우는 inf**를 나타낸다.
 
![부동소수점 32비트 float](https://github.com/uuranus/personal_study/assets/72340294/0c13d87f-12d1-4c02-ae0f-97b88f5e061f)

![부동소수점 64비트 double](https://github.com/uuranus/personal_study/assets/72340294/d9ed13f7-21d1-4c07-ae7e-1695b3a409a6)




# 출처
https://www.tcpschool.com/cpp/cpp_datatype_floatingPointNumber
