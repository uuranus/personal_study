
# 부동소수점
- 컴퓨터에서 **실수를 저장하는 방법** 중 하나
- 고정 소수점과 부동소수점이 있다.

## 고정 소수점 (fixed point)
- **소수점의 위치가 고정**되어 있음
![고정 소수점](https://github.com/uuranus/personal_study/assets/72340294/79fb1204-c2d1-47fd-8a21-f85456abfcbd)


- 11010.001101 을 저장한다고 하면
- 부호 0 정수부 11010 소수부 001101 이라서 0 11010 001101 이라고 저장

- 장점: **읽기가 쉽다.** 그냥 정수부와 소수부 사이에 .만 붙이면 됨
- 단점: **표현 범위가 좁다** 1.10110110110101.... 이런 숫자여도 정수부의 비트를 나눠줄 수 없음

## 부동소수점 (floating point)
- **가수부와 지수부**로 나누어서 소수점의 위치를 표현
- 11011.111010 이런 숫자가 있으면 1.1011111010 * 2^4 로 정규화를 진행
- 그리고 가수부에는 맨 앞 1을 제외한 1011111010을 저장 (**맨 앞이 무조건 1인 것을 알기에 생략**. 나중에 계산할 때는 1을 더해줌)
- **지수부는** 4를 저장하는데 이 때 **bias 값을 더해서 저장**. 32비트는 127, 64비틑 1024이다. **(2^(지수부 비트수 -1) -1)**
- 이는 **부호비트를 사용하지 않게 하기 위함**
- 정수부는 8비트이기에 -2^7 -1 ~ 2^7까지 표현가능. 즉, 2^ (-126~ 127)까지 가능
- 여기에 +127을 해서 저장한다면 1~254로 저장이 되어서 부호비트를 사용하지 않아도 됨
- **왜 부호비트를 안 쓰려고** 하나?
   - 부호비트가 있으면 1xxx가 음수, 0xxx가 양수가 된다.
   - 근데 지수부는 **중간 일부비트**를 사용하는거라서 2의 보수로 표현해도 **컴퓨터가 음수로 읽어주지 않음**
   - 그러면 지수가 음수인 값이 지수가 양수인 값보다 부동소수점 표시값이 더 큰 값으로 표시가 됨
   - 그럼 부동소수점 32비트를 보고 바로 크기비교를 못하고 이를 다시 계산해서 비교해야하는데 그게 싫음
   - **부동소수점 값도 오름차순으로 유지**되었으면 좋겠어
   - 그래서 **bias 값을 통해서 양수로** 만들어서 오름차순으로 만든 것

- 장점: **표현 범위가 넓어졌다.**
- 단점: **오차 존재**

- 그럼 0이랑 255는 어디에 쓰는가?


### denormalize
- 소수를 1.xxx * 2^yyyy 형태로 바꾼다고 했다.
- 그럼 0.xxx는 없는가?
- 소수점은 최대 왼쪽으로 126칸까지 이동할 수 있는데 만약 **매우매우 작은 숫자**라서 000..00000(126개)011101..이런 숫자가 있다면?
- 0.01101 * 2^ -126 이렇게까지가 최선일 것이다. **0.xxx의 지수는 최대치로 소수점을 땡길 수 있는 2^-126으로 정해지는 것**
- 이 때 exp가 0이면 denormalize값이라고 정함 (아까 1.xx의 1이 생략되어 있어서 denoramlize인 경우를 따로 표시해줘야 함) 지수는 **1-bias 로 계산식이 정해져있다.**
- 이렇게 해서 매우 작은 숫자도 표현 가능

- **지수가 255로 다 1111인 경우는 inf**를 나타낸다.
 
![부동소수점 32비트 float](https://github.com/uuranus/personal_study/assets/72340294/0c13d87f-12d1-4c02-ae0f-97b88f5e061f)

![부동소수점 64비트 double](https://github.com/uuranus/personal_study/assets/72340294/d9ed13f7-21d1-4c07-ae7e-1695b3a409a6)


## 결론
- 부동소수점은 -126~127 (-2^(n-1) -1 ~ 2^(n-1))까지 소수점을 이동시킬 수 있음
- 1.xxx * 2^yyy로 정규화시켜서 저장하는데 처음 나오는 1이 126번째보다도 더 뒤면 0.xxx * 2^-126으로 표현하는게 소수점의 한계임
- 0.xxx로 표현되는 애들은 정규화를 못 시킨 것이니까 denormalize라고 부르고 지수값은 2^(n-1) -1 로 고정이 됨. 그래서 1 - bias라고 계산식을 정해버림
- 근데 지수부를 그냥 2의 보수로 표현하니까 1xxx가 음수이지만 컴퓨터가 더 큰 값이라고 읽음
- 실제 실수 크기순서대로 부동소수점 값 자체도 오름차순을 유지했으면 좋겠어서 bias를 통해 다 0~255로 양수로 만들어서 오름차순을 유지시킴


# 출처
https://www.tcpschool.com/cpp/cpp_datatype_floatingPointNumber
