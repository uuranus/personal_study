선형 자료구조

# Array
- 메모리에 연속적으로 데이터를 저장하는 선형 자료구조
- 인덱스를 통해서 데이터에 O(1)시간에 접근 가능
- 미리 사이즈를 정해놔야 하기에 메모리 낭비가 될 수 있음
- 탐색 -> O(1)
- 추가 -> 앞에 추가하면 한 칸씩 밀어야해서 O(n)
- 삭제 -> 앞 데이터를 삭제하면 한 칸씩 밀어야 해서 O(n)

# ArrayList
- 동적 배열
- 배열이 꽉 차면 2배로 확장하고 데이터가 1/4로 줄어들면 절반 크기로 줄여서 메모리의 효율성을 높임
- 탐색 O(1), 삭제 O(n)
- 추가의 경우 배열을 확장하는 경우에는 O(n)이 소요되는데 상각분석으로 평균을 내보면 O(1)시간이 걸림

# LinkedList
- 데이터와 다음 노드를 가리키는 포인터를 가진 Node라는 데이터 구조체로 연결되어있는 선형 자료구조
- head 변수를 통해서 앞에서부터 포인터를 따라 이동하면서 탐색 -> O(n)시간 소요 
- 추가,삭제는 새로운 구조체를 추가하고 레퍼런스 값만 변경해주면 되기에 O(1)시간 소요
- 다음 노드만 가리키는 SinglyLinkedList, 양쪽 노드를 가리키는 DoubleLinkedList가 존재

**ArrayList vs LinkedList**
- 양쪽 끝에서 데이터를 추가,삭제할 일이 많다 -> LinkedList
- 중간에서 데이터를 추가,삭제할 일이 많다 -> LinkedList (why? 둘 다 O(n)이지만 ArrayList는 한칸씩 땡기는 데 O(n)이고 LinkedList는 중간까지 탐색하는 데 O(n)임)
- 끝에서만 데이터 추가,삭제,탐색할 일이 많다 -> ArrayList (why? 인덱스로 접근하기에 빠르게 접근 가능하며 LinkedList는 객체 만드는 시간이 소요)

# Stack
- LIFO (Last In First Out) 선형 자료구조
- 한 쪽 끝에서만 데이터를 추가,삭제,탐색 함 -> O(1) 소요
- LinkedList or ArrayDeque 구현
- ex. 브라우저 히스토리, 함수 호출
- 

# Queue
- FIFO (First In First Out) 선형 자료구조
- 한 쪽에서 추가하고 다른 한 쪽에서 삭제하는 구조 -> O(1) 소요
- LinkedList로 구현 
- ex. 대기 줄
 
