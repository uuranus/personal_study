

# HTTP
- 응용 계층의 프로토콜
- '메시지' 단위로 데이터를 주고받는다.
- 시작줄
- 헤더
- 본문 (body)
- 로 구성되어 있다.

## 시작줄

요청 시에는 method , url, version 으로 구성되어 있고

응답에는 status Code, reason phrase로 구성

**Method**
- 클라이언트가 서버에게 요청하는 행동
- GET -> 자원 요청
- POST -> 새로운 리소스를 생성
- PUT -> 데이터를 통째로 덮어쓴다. 기존에 리소스가 없을 시 새로 추가
- PATCH -> 기존 리소스의 일부를 변경
- DELETE -> 데이터를 삭제
- TRACE -> 서버 도달과정 추적. 보안 상의 이유로 현재는 비활성화되어 있는 경우 많음
- HEAD -> 요청한 데이터의 헤더값만 보냄
- OPTIONS -> 서버가 지원하는 메서드를 조회할 수 있음

- 멱등성(idempotent)
  - 서버에게 여러번 반복요청에도 서버에게 데이터에 영향이 없는 메서드
  - GET, PUT, DELETE가 멱득성이 있다.
  - why? 여러번 get을 해와도 서버의 데이터에는 영향이 없고 put, delete는 항상 전체를 새로 덮어쓰거나 삭제하기에 영향이 없음
  - POST나 PATCH를 보면 POST는 중복요청하면 중복 데이터가 계속 생기고 PATCH의 경우 변경한 부분이 데이터의 길이가 동일하다는 보장이 없기 때문

- RESTful API
  - 웹 서비스 구조 아키텍쳐
  - REST 아키텍쳐로 API를 구성했으면 RESTful 하다고 함
  -  URL로 자원을 구분하며 CRUD로 자원을 조작할 수 있고 자원은 JSON or XML로 표현
  1. Uniform Method -> 플랫폼이 바뀌어도 동일하게 인터페이스가 동일하여 동일하게 적용 가능
  2. Self-Descriptiveness -> 메시지만 봐도 어떤 요청,응답인 지 알 수 있음
  3. Cacheable -> HTTP의 캐시 정책 그대로 사용 가능
  4. Stateless -> 클라이언트의 상태를 기억하지 않음
  5. Client-Server -> 계층형 서버 구조 가능


**status code**

- 클라이언트가 요청한 메서드에 대한 응답 상태를 알림

- 200번대 - 정상
- 300번대 - 리다이렉션
- 400번대 - 클라이언트 오류
- 500번대 - 서버 오류

**사유 구절 (reason phrase)**

- 상태코드에 대한 추가 설명 문자열

## 헤더
- 클라이언트가 서버에게 요청할 때 필요한 데이터들을 포함
- ex. Content-XX, If-Modified-Since

### 캐시 헤더
- 데이터 요청은 중간에 캐시 서버에 데이터가 있는 지 확인
- 캐시 미스이면 원서버로 보내서 데이터를 가져와서 저장한 후 사용자에게 전달하며
- 캐시 히트인 경우는 가지고 있는 데이터의 신선도를 검사
  - if 신선함 -> 사용자에게 캐시 데이터를 제공
  - else -> 원서버에게 자신이 가지고 있는 데이터 이후에 변경된 것이 있는 지 확인
          -> 이 때 캐시 헤더를 보낸다.
- Cache-Control 헤더를 통해 캐시 정책을 설정할 수 있음

- if-since-modified
  -> 캐시를 저장할 때 받았던 last-modified 헤더 값을 전달하면서 이 이후에 원서버에게 데이터가 수정이 일어났는 지 확인한다.
  -> 만약 바뀐 값이 없으면 새로운 유효기간만 갱신하며 바뀌었다면 변경된 데이터로 갱신한다.
- if-none-match
  -> 시간으로 유효기간을 정하지 않고 ETag를 통해서 데이터 버전을 관리하는 방식이다.
  -> 해당 캐시 데이터의 태그 값 이후로 원서버 데이터가 업데이트 되었는 지 확인한다.
 
# HTTPS
- 인터넷을 통해서 중요한 데이터들을 보내게 되면서 보안이 중요해졌다.
- http -> tcp로 보내기 전에 중간에 SSL or TSL 레이어가 추가되어서 이 레이어에서 암호화를 진행한다.

## 공개키, 대칭키 방식
- 대칭키 (symmetric key)
  - 인코딩, 디코딩할 때 동일한 키로 암호화를 진행 ex. DES
  - 송수신자가 동일한 키를 가지고 있어야 함
  - 서로 키를 교환하는 과정에서 유출될 가능성이 있고 통신하는 호스트마다 키가 있어야 해서 키 관리가 힘듦
- 공개키 (public key or asymmetric key)
  - 인코딩할 때 사용하는 공개키, 디코딩할 때 사용하는 암호키로 인코딩, 디코딩의 키가 다른 암호화 방식 ex. RSA
  - 송신자는 수신자의 공개키로 인코딩해서 전송하고 수신자는 자신의 비밀키로 디코딩
  - 보안성이 높고 키 관리가 쉽지만 알고리즘이 복잡하여 느림
    
### 디지털 인증
  - 공개키 방식으로 데이터의 위조여부를 확인할 수 있음
  - ex. A가 자신이 보낼 문서에 자신의 비밀키로 안호화한 서명을 같이 보냄 -> B는 A의 공개키로 복호화함 -> 복호화한 내용이 받은 평문이랑 일치하는 지 확인
    
## SSL Handshake
- 클라이언트와 서버가 서로 신뢰를 확인한 후 세션 키를 생성하고, 이후의 통신은 대칭키로 암호화됨
- 서버의 인증서를 통해 신뢰할 수 있는 서버인지 확인 후 대칭키를 교환하는 과정이 SSL Handshake
  - 서버의 인증서는 서버의 정보와 디지털 인증이 있는 문서로 클라이언트는 이를 서버의 공개키로 복호화해서 내용이 일치하는 지 확인
  - 이 때 서버의 공개키는 브라우저가 가지고 있는데 브라우저가 공개키를 가지고 있지 않은 서버의 경우 '신뢰할 수 없는 사이트입니다'라고 경고창이 뜸

# 자원 (resource)
- 메시지를 통해서 주고받는 모든 데이터는 자원이라고 한다.
- 자원을 주고받기 위해서는 자원을 구별할 수 있는 식별자(identifier)가 필요한데 이를 URI(Uniform Resource Indentifier)라고 하고 URL과 URN이 존재
- URL (Uniform Resource Location)
  - 자원의 **위치**를 이용해 식별함
  - https://www.google.com/hello/folder/index.html?id=1235&name='hello'#second 와 같은 형식으로 이루어져 있다.
  - scheme -> https 부분으로 해당 자원에 접근할 수 있는 프로토콜을 의미 ex. https, ftp
  - authority -> 자원을 가지고 있는 호스트를 특정하는 정보로 domain name or ip로 구성
  - path -> 호스트에서 자원이 존재하는 파일의 경로
  - query -> 자원을 찾을 때 필요한 추가정보로 ?키=데이터&키=데이터 형태로 URL뒤에 붙여서 사용
  - fragment -> 자원 조각. 특정 자원을 가져온 후 해당 파트 부분으로 스크롤을 옮겨서 보여준다.
- URN (Uniform Resource Name)
  - URL은 자원의 위치가 바뀌면 더 이상 유효하지 않다는 단점이 존재
  - 그래서 위치에 상관없이 **이름**을 통해서 자원을 찾을 수 있는 식별자
  - ex. ISBN
